#!/usr/bin/env python3.11

# Copyright (c) 2024-2024 Burak Günaydin
# All Rights Reserved
#
# This software is the confidential and proprietary information of
# Burak Günaydin. You may not use, modify, or distribute this
# software (unless you have the permission of the copyright holder)
# except in accordance with the terms of any applicable license agreement.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

# System imports
import importlib
import os

# From own imports
from src.Command import Command
from src.BaseCLI import BaseCLI

CURRENT_DIRECTORY = os.path.dirname(os.path.abspath(__file__))
SCRIPTS_DIR = f'{CURRENT_DIRECTORY}/scripts'

# TODO: Replace with package constant
TAB='    '

class MainCLI(BaseCLI):
    def meta(self):
        return {
            'name': 'homepie',
            'shorthand': 'hp',
            'help': 'Main CLI that manages and runs available commands from the "scripts" directory.'
        }
        
    def load_scripts(self):
        """
        Discover and import all Python scripts in the `scripts/` directory, skipping __init__.py and non-Python files.
        """
        scripts = {}
        for filename in os.listdir(SCRIPTS_DIR):
            # TODO: Skip files that are not of class BaseCLI
            if filename != '__init__.py' and filename != '__pycache__':
                # TODO: Make this lazy and only if needed
                formatted_module_name = filename.replace('-', '_')
                formatted_filename = formatted_module_name + '.py' # Convert filename from kebab-case to snake_case for import
                os.rename(os.path.join(SCRIPTS_DIR, filename), os.path.join(SCRIPTS_DIR, formatted_filename))
                
                try:
                    module = importlib.import_module(f'scripts.{formatted_module_name}')
                finally:
                    # Revert the filename back to its original form
                    os.rename(os.path.join(SCRIPTS_DIR, formatted_filename), os.path.join(SCRIPTS_DIR, filename).replace('.py', ''))
                    
                # Convert kebab-case to CamelCase
                camel_case_name = ''.join(word.capitalize() for word in formatted_module_name.split('_'))
                script_class = getattr(module, f'{camel_case_name}')
                script_instance = script_class(auto_preinit=False,
                                               auto_parse=False,
                                               auto_validate=False,
                                               auto_execute=False)
                scripts[script_instance.name] = script_instance
        return scripts
    
    def print(self):
        indented_formatted_string = '\n'
        
        # Add usage information to the formatted string
        indented_formatted_string += 'Usage:\n'
        indented_formatted_string += f'{TAB}hp <script> [args]'
        indented_formatted_string += '\n'
        indented_formatted_string += '\n'
        indented_formatted_string += f'Scripts:\n'
        
        # Iterate over each script and add its details to the formatted string
        for index, script_key in enumerate(self.scripts):
            script = self.scripts[script_key]
            script_str = script.format_str(include_args=False, include_meta=True, minify_usage=True, tab_padding=1)
            
            if index > 0:
                indented_formatted_string += '\n'
                
            indented_formatted_string += f'{script_str}'
            indented_formatted_string += '\n'
                
        indented_formatted_string += '\n'
        indented_formatted_string += 'Hint: Use <script> -h, --help flag for usage information.'
        indented_formatted_string += '\n'
            
        print(indented_formatted_string)
    
    def execute(self):
        """
        Handles the execution of the selected command or lists all commands if no command is provided.
        
        This method first loads all available scripts from the `scripts/` directory and initializes them.
        It then creates a list of `Command` objects for each script.
        After parsing the command-line arguments, it either prints the available commands if no specific command is provided,
        or it executes the selected command.
        """
        
        # Load all available scripts from the `scripts/` directory
        self.scripts = self.load_scripts()
        
        # Initialize an empty list to store command objects
        self.commands = []
        
        # Iterate over each script and create a Command object for it
        for script_key in self.scripts:
            script = self.scripts[script_key]
            command = Command(name=script.name,
                              shorthand=script.shorthand,
                              help=script.help)
            self.commands.append(command)
            
        self.parse_args() # Parse the command-line arguments
        
        # If no command or flags are provided, print the available commands
        if len(self.parsed_arguments) == 0 and len(self.parsed_flags) == 0:
            self.print()
            return
        
        try:
            # Retrieve the script name from the parsed command
            script_name = self.parsed_command
            
            # Iterate over the scripts to find the one matching the shorthand command
            for script_key in self.scripts:
                script = self.scripts[script_key]
                if script.shorthand == self.parsed_command:
                    script_name = script.name
            
            # Retrieve the selected script based on the parsed command
            selected_script = self.scripts[script_name]
            # Parse the arguments for the selected script
            selected_script.parse_args()
            # Remove the script name from the arguments list
            del selected_script.parsed_arguments[0]
            # Validate the arguments for the selected script
            selected_script.validate_args()
            
            # Execute the selected script
            selected_script.execute()
        except SystemExit:
            # Handle the SystemExit exception to prevent the program from exiting
            pass
        except:
            # Validate arguments if an exception occurs
            self.validate_args()

if __name__ == '__main__':
    main_cli = MainCLI(auto_parse=False, auto_validate=False)